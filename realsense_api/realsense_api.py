import numpy as np
import pyrealsense2 as rs
# from realsense_api.post_processing.option import OptionType
from realsense_api.post_processing.options import \
    DecimationOptions, SpatialOptions, TemporalOptions, HoleFillingOptions, OptionType

# TODO: 
#   - Create a method for loading the json options that are generated by the realsense viewer
#   - Create a method for displaying the options that are currently set
#   - Add any remaining stream types into the get data method such as confidence
#   - Add any other post processing filters that are missing

# Links that I thought would be useful later:
#   https://intelrealsense.github.io/librealsense/python_docs/_generated/pyrealsense2.threshold_filter.html?highlight=process
#   https://github.com/IntelRealSense/librealsense/issues/6902
#   https://github.com/IntelRealSense/librealsense/issues/10078

class RealSenseCamera:

    def __init__(self, 
                 depth_stream_width=640, depth_stream_height=480,
                 color_stream_width=1280, color_stream_height=720,
                 depth_stream_fps=30, color_stream_fps=30,
                 ros_bag = None):

        # Used if openings stream from prerecorded ros .bag file
        # holds the path to the .bag file
        self.ros_bag = ros_bag

        # Resolution attributes
        self.depth_stream_width = depth_stream_width
        self.depth_stream_height = depth_stream_height
        self.color_stream_width = color_stream_width
        self.color_stream_height = color_stream_height

        self.depth_stream_fps = depth_stream_fps
        self.color_stream_fps = color_stream_fps

        # Data attributes that will be set with get_data()
        self.frameset = None
        self.depth_frame = None
        self.color_frame = None
        self.infrared_frame = None
        self.color_intrinsics = None
        self.depth_scale = None

        # Holds the frameset after it has undergone filtering 
        self.filtered_frameset = None

        # Aligned frame holders
        self.depth_frame_aligned = None
        self.color_frame_aligned = None
        self.infrared_frame_aligned = None

        # Post Processing Filter attributes with default values
        # https://dev.intelrealsense.com/docs/post-processing-filters

        self.decimation: DecimationOptions = DecimationOptions()
        self.spatial: SpatialOptions = SpatialOptions()
        self.temporal: TemporalOptions = TemporalOptions()
        self.hole_filling: HoleFillingOptions = HoleFillingOptions()

        # Decimation filter attribute 
        self.decimation_magnitude = 3
        
        # Spatial filter attributes
        self.spatial_magnitude = 2
        self.spatial_smooth_alpha = 1
        self.spatial_smooth_delta = 20
        self.spatial_holes_fill = 1

        # Temporal filter attributes
        self.temporal_smooth_alpha = 0.4
        self.temporal_smooth_delta = 20
        self.persistency_index = 8

        # Holes Filling filter attribute
#        self.hole_filling = 1

        # Configure and start streams
        self.pipeline = rs.pipeline()
        config = rs.config()
        if ros_bag:
            print('ros')
            config.enable_device_from_file(self.ros_bag)
        else:
            config.enable_stream(rs.stream.depth,
                                 self.depth_stream_width, self.depth_stream_height,
                                 rs.format.z16, self.depth_stream_fps)

            config.enable_stream(rs.stream.color,
                                 self.color_stream_width, self.color_stream_height,
                                 rs.format.bgr8, self.color_stream_fps)

            config.enable_stream(rs.stream.infrared,
                                 rs.format.y8,
                                 self.depth_stream_fps)

        self.profile = self.pipeline.start(config)

    # def get_options(self):
    def get_data(self, color_intrinsics=False):

        self.frameset = self.pipeline.wait_for_frames()
        self.depth_frame = self.frameset.get_depth_frame()
        self.color_frame = self.frameset.get_color_frame()
        self.infrared_frame = self.frameset.first(rs.stream.infrared)
        
        # Get depth scale
        depth_sensor = self.profile.get_device().first_depth_sensor()
        self.depth_scale = depth_sensor.get_depth_scale()
        
        if color_intrinsics:                
            self.color_intrinsics = self.color_frame.profile \
                                    .as_video_stream_profile() \
                                    .intrinsics

    def get_aligned_frames(self, frameset, aligned_to_color=False, aligned_to_depth=False):

        if aligned_to_color:
            align_to = rs.stream.color
            align = rs.align(align_to)
            frameset = align.process(frameset)

        if aligned_to_depth:
            align_to = rs.stream.depth
            align = rs.align(align_to)
            frameset = align.process(frameset)
 
        self.depth_frame_aligned    = frameset.get_depth_frame()
        self.color_frame_aligned    = frameset.get_color_frame()
        self.infrared_frame_aligned = frameset.first(rs.stream.infrared)

    def filter_depth_data(self,
                          enable_decimation = False,
                          enable_spatial = False,
                          enable_temporal = False,
                          enable_hole_filling = False):

        '''Apply a cascade of filters on the depth frame'''

        depth_to_disparity = rs.disparity_transform(True)
        disparity_to_depth = rs.disparity_transform(False)

        frameset = self.frameset
        # DECIMATION FILTER
        if enable_decimation:
            decimation = rs.decimation_filter()
            decimation.set_option(
                rs.option.filter_magnitude, 
                self.decimation.options[OptionType.MAGNITUDE].option_value
            )
            frameset = decimation.process(frameset).as_frameset()

        # SPATIAL FILTER
        if enable_spatial:
            spatial = rs.spatial_filter()
            spatial.set_option(
                rs.option.filter_magnitude,
                self.spatial.options[OptionType.MAGNITUDE].option_value
            )
            spatial.set_option(
                rs.option.filter_smooth_alpha,
                self.spatial.options[OptionType.SMOOTH_ALPHA].option_value
            )
            spatial.set_option(
                rs.option.filter_smooth_delta,
                self.spatial.options[OptionType.SMOOTH_DELTA].option_value
            )
            spatial.set_option(
                rs.option.holes_fill,
                self.spatial.options[OptionType.HOLE_FILLING].option_value
            )
            frameset = spatial.process(frameset).as_frameset()

        # TEMPORAL FILTER
        if enable_temporal:
            temporal = rs.temporal_filter()
            temporal.set_option(
                rs.option.filter_smooth_alpha,
                self.temporal.options[OptionType.SMOOTH_ALPHA].option_value
            )
            temporal.set_option(
                rs.option.filter_smooth_delta,
                self.temporal.options[OptionType.SMOOTH_DELTA].option_value
            )
            temporal.set_option(
                rs.option.holes_fill,
                self.temporal.options[OptionType.PERSISTENCY_INDEX].option_value
            )
            frameset = temporal.process(frameset).as_frameset()

        # HOLE FILLING
        if enable_hole_filling:
            hole_filling = rs.hole_filling_filter()
            hole_filling.set_option(
                rs.option.holes_fill,
                self.hole_filling.options[OptionType.HOLE_FILLING].option_value
            )
            frameset = hole_filling.process(frameset).as_frameset()

        self.filtered_frameset = frameset

    def frame_to_np_array(self, frame, colorize_depth = False):
        # Create colorized depth frame
        if colorize_depth:
            colorizer = rs.colorizer()
            frame_as_image = np.asanyarray(colorizer.colorize(frame).get_data())
            return frame_as_image
        frame_as_image = np.asanyarray(frame.get_data())
        return frame_as_image


    def stop(self):
        self.pipeline.stop()
