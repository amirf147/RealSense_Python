import numpy as np
import pyrealsense2 as rs

# TODO: 
#   - Create a method for loading the json options that are generated by the realsense viewer
#   - Create a method for displaying the options that are currently set
#   - Add any remaining stream types into the get data method such as confidence
#   - Add any other post processing filters that are missing

# Links that I thought would be useful later:
#   https://intelrealsense.github.io/librealsense/python_docs/_generated/pyrealsense2.threshold_filter.html?highlight=process
#   https://github.com/IntelRealSense/librealsense/issues/6902
#   https://github.com/IntelRealSense/librealsense/issues/10078

class RealSenseCamera:

    def __init__(self, ros_bag = None):

        # Used if openings stream from prerecorded ros .bag file
        # holds the path to the .bag file
        self.ros_bag = ros_bag

        # Data variables that will be set with get_data()
        self.frameset = None
        self.depth_frame = None
        self.color_frame = None
        self.infrared_frame = None
        self.color_intrinsics = None
        self.depth_scale = None

        # Holds the data frame after it has undergone filtering 
        self.filtered_frameset = None

        # Aligned frame holders
        self.depth_frame_aligned = None
        self.color_frame_aligned = None
        self.infrared_frame_aligned = None

        # Post Processing Filter variables with default values
        # https://dev.intelrealsense.com/docs/post-processing-filters

        # Decimation filter variable 
        self.decimation_magnitude = 2
        
        # Spatial filter variables
        self.spatial_magnitude = 2
        self.spatial_smooth_alpha = 1
        self.spatial_smooth_delta = 20
        self.spatial_holes_fill = 1

        # Temporal filter variables
        self.temporal_smooth_alpha = 0.4
        self.temporal_smooth_delta = 20
        self.persistency_index = 8

        # Holes Filling filter variable
        self.hole_filling = 1

        # Configure and start streams
        self.pipeline = rs.pipeline()
        config = rs.config()
        if ros_bag:
            config.enable_device_from_file(self.ros_bag)
        else:
            config.enable_stream(rs.stream.depth, rs.format.z16, 30)
            config.enable_stream(rs.stream.color, rs.format.bgr8, 30)
            config.enable_stream(rs.stream.infrared, rs.format.y8, 30)
        self.profile = self.pipeline.start(config)

        # Get depth scale
        depth_sensor = self.profile.get_device().first_depth_sensor()
        self.depth_scale = depth_sensor.get_depth_scale()

    # def get_options(self):
    def get_data(self, color_intrinsics=False):

        self.frameset = self.pipeline.wait_for_frames()
        self.depth_frame = self.frameset.get_depth_frame()
        self.color_frame = self.frameset.get_color_frame()
        self.infrared_frame = self.frameset.first(rs.stream.infrared)
        
        if color_intrinsics:                
            self.color_intrinsics = self.color_frame.profile \
                                    .as_video_stream_profile() \
                                    .intrinsics

    def get_aligned_frames(self, aligned_to_color=False, aligned_to_depth=False):

        frameset = self.frameset

        if aligned_to_color:
            align_to = rs.stream.color
            align = rs.align(align_to)
            frameset = align.process(frameset)

        if aligned_to_depth:
            align_to = rs.stream.depth
            align = rs.align(align_to)
            frameset = align.process(frameset)
 
        self.filtered_frameset = frameset
        self.depth_frame_aligned = self.filtered_frameset.get_depth_frame()
        self.color_frame_aligned = self.filtered_frameset.get_color_frame()
        self.infrared_frame_aligned = self.filtered_frameset.first(rs.stream.infrared)

    def filter_depth_data(self,
                          enable_decimation = False,
                          enable_spatial = False,
                          enable_temporal = False,
                          enable_hole_filling = False):

        '''Apply a cascade of filters on the depth frame'''

        depth_to_disparity = rs.disparity_transform(True)
        disparity_to_depth = rs.disparity_transform(False)

        frameset = self.frameset
        # DECIMATION FILTER
        if enable_decimation:
            decimation = rs.decimation_filter()
            decimation.set_option(rs.option.filter_magnitude, self.decimation_magnitude)
            frameset = decimation.process(frameset).as_frameset()

        # SPATIAL FILTER
        if enable_spatial:
            spatial = rs.spatial_filter()
            spatial.set_option(rs.option.filter_magnitude, self.spatial_magnitude)
            spatial.set_option(rs.option.filter_smooth_alpha, self.spatial_smooth_alpha)
            spatial.set_option(rs.option.filter_smooth_delta, self.spatial_smooth_delta)
            
            spatial.set_option(rs.option.holes_fill, self.spatial_holes_fill)
            frameset = spatial.process(frameset).as_frameset()

        # TEMPORAL FILTER
        if enable_temporal:
            temporal = rs.temporal_filter()
            temporal.set_option(rs.option.filter_smooth_alpha, self.temporal_smooth_alpha)
            temporal.set_option(rs.option.filter_smooth_delta, self.temporal_smooth_delta)
            temporal.set_option(rs.option.holes_fill, self.persistency_index)
            frameset = temporal.process(frameset).as_frameset()

        # HOLE FILLING
        if enable_hole_filling:
            hole_filling = rs.hole_filling_filter()
            hole_filling.set_option(rs.option.holes_fill, self.hole_filling)
            frameset = hole_filling.process(frameset).as_frameset()

        self.filtered_frameset = frameset

    def frame_to_np_array(self, frame, colorize_depth = False):
        # Create colorized depth frame
        if colorize_depth:
            colorizer = rs.colorizer()
            frame_as_image = np.asanyarray(colorizer.colorize(frame).get_data())
            return frame_as_image
        frame_as_image = np.asanyarray(frame.get_data())
        return frame_as_image


    def stop(self):
        self.pipeline.stop()
